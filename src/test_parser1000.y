//ignoring all the copy paste suff only grammar:
%code requires{
  #include "abstsyntree.hpp"

  #include <cassert>
	#include <fstream>
	#include <string>
  extern nodePtr g_root; // A way of getting the AST out

  //! This is to fix problems when generating C++
  // We are declaring the functions provided by Flex, so
  // that Bison generated code can call them.
  int yylex(void);
  void yyerror(const char *);
}


//The %union DECL specifies the entire collection of possible data types for
//semantic values. The keyword %union is followed by braced code containing the same
//thing that goes inside a union in C.

%union{
  nodePtr expr;
  double number;
  std::string *string;
}

%token T_NUMBER T_IDENTIFIER T_STRING T_CONST
%token T_PLUS T_MINUS T_DIVIDE T_STAR T_MOD
%token T_POINT T_INCR T_DECR T_LSHIFT T_RSHIFT T_EQ T_NEQ T_GT T_GTE T_LT T_LTE T_NOT
%token T_AND T_OR T_BWXOR T_BWAND T_BWOR T_BWNOT
%token  T_EQMULT T_EQDIV T_EQMOD T_EQPLUS T_EQMINUS T_EQLSHIFT T_EQRSHIFT T_ASSIGN T_EQEXPONENT T_EQBWOR T_EQBWAND
%token  T_TYPE_NAME T_SIZEOF T_SEMI T_QBEGIN T_QEND T_DOT T_COMM

%token T_TYPEDEF T_EXTERN T_STATIC T_AUTO T_REGISTER
%token T_CHAR T_SHORT T_INT T_LONG T_SIGNED T_UNSIGNED T_FLOAT T_DOUBLE T_VOLATILE T_VOID
%token T_STRUCT T_UNION T_ENUM T_ELL
%token T_LBRACKET T_RBRACKET T_LSQBRACKET T_RSQBRACKET T_LCBRACKET T_RCBRACKET

%token T_CASE T_DEFAULT T_IF T_ELSE T_SWITCH T_WHILE T_DO T_FOR T_GOTO T_CONTINUE T_BREAK T_RETURN



%type <expr> START EXTERNAL_DECLARATION FUNCTION_DEFINITION BODY DECLARATION
%type <expr> STATEMENT EXPRESSION_STATEMENT COMPOUND_STATEMENT JUMP_STATEMENT
%type TYPE_SPECIFIER



%type <number> T_NUMBER
%type <string> T_IDENTIFIER T_STRING T_INCR T_DECR T_LBRACKET T_RBRACKET
%type <string> T_WHILE T_IF T_ELSE

%start START

START
	:EXTERNAL_DECLARATION // FUNCTION DEF ONLT ATM
	|START EXTERNAL_DECLARATION //MULTIPLE FUNCTIONS CAN BE DEFINED BEFORE THE MAIN
	;

EXTERNAL_DECLARATION
	:FUNCTION_DEFINITION
	//DECLERATIONS NOT NEEDED AS WE ARE NOT PARSING GLOBAL VARIABLES, STRUCTS ECT ATM
	;

FUNCTION_DEFINITION
	//NO TYPE QUALIFIERS EG CONST CURRENTLY NEEDED
	//IDENTIFIER IS NAME OF STUFF EG VARIABLE, FUNCTION ECT THINK WE CURRENTLY LEX VARIABLE
	//BODY IS COMPOUND STATEMENT SIMULAR*** TO STUFF0 IN PEREVIOUS LEX
	:TYPE_SPECIFIER IDENTIFIER BODY

COMPOUND_STATEMENT
	: T_LCBRACKET T_RCBRACKET
	| T_LCBRACKET BODY T_RCBRACKET

BODY //EMULATES LIST FOR BOTH STATEMENT AND DECLARATION
	: STATEMENT
	| DECLARATION
	| STATEMENT BODY
	| DECLARATION BODY
	;

STATEMENT
	:SELECTION_STATEMENT
	|ITERATION_STATEMENT
	|EXPRESSION_STATEMENT //THINK THIS IS THEN THE TERM FACTOR SUFFF LOOK INTO
	|COMPOUND_STATEMENT	//MAY NEED THE DELETION OF BODY
	|JUMP_STATEMENT
	;

SELECTION_STATEMENT
	: T_IF T_LBRACKET EXPRESSION T_RBRACKET COMPOUND_STATEMENT //they use statement not compound why????
	| T_IF T_LBRACKET EXPRESSION T_RBRACKET COMPOUND_STATEMENT T_ELSE COMPOUND_STATEMENT
	;

ITERATION_STATEMENT
	: T_WHILE '(' EXPRESSION ')' COMPOUND_STATEMENT
	;

JUMP_STATEMENT
	: T_RETURN
	| T_RETURN EXPRESSION
	;

EXPRESSION_STATEMENT
	: EXPRESSION T_SEMI
	: ; //UNSURE HOW THIS WORKS IN THE STATEMENT STUFF YIKES

EXPRESSION
	: ASSIGNMENT_EXPRESSION
	| EXPRESSION T_COMM ASSIGNMENT_EXPRESSION
